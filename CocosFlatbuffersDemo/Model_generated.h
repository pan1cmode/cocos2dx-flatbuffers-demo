// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_MODEL_FBS_H_
#define FLATBUFFERS_GENERATED_MODEL_FBS_H_

#include "flatbuffers/flatbuffers.h"


namespace fbs {

struct SkillModel;
struct GameModel;

///skill model
MANUALLY_ALIGNED_STRUCT(4) SkillModel {
 private:
  int32_t skillId_;
  int32_t skillLevel_;

 public:
  SkillModel(int32_t skillId, int32_t skillLevel)
    : skillId_(flatbuffers::EndianScalar(skillId)), skillLevel_(flatbuffers::EndianScalar(skillLevel)) { }

  int32_t skillId() const { return flatbuffers::EndianScalar(skillId_); }
  int32_t skillLevel() const { return flatbuffers::EndianScalar(skillLevel_); }
};
STRUCT_END(SkillModel, 8);

///game model
struct GameModel : private flatbuffers::Table {
  uint32_t username() const { return GetField<uint32_t>(4, 150); }
  int64_t level() const { return GetField<int64_t>(6, 100); }
  const flatbuffers::Vector<const SkillModel *> *skills() const { return GetPointer<const flatbuffers::Vector<const SkillModel *> *>(8); }
  int32_t gold() const { return GetField<int32_t>(10, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, 4 /* username */) &&
           VerifyField<int64_t>(verifier, 6 /* level */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* skills */) &&
           verifier.Verify(skills()) &&
           VerifyField<int32_t>(verifier, 10 /* gold */) &&
           verifier.EndTable();
  }
};

struct GameModelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_username(uint32_t username) { fbb_.AddElement<uint32_t>(4, username, 150); }
  void add_level(int64_t level) { fbb_.AddElement<int64_t>(6, level, 100); }
  void add_skills(flatbuffers::Offset<flatbuffers::Vector<const SkillModel *>> skills) { fbb_.AddOffset(8, skills); }
  void add_gold(int32_t gold) { fbb_.AddElement<int32_t>(10, gold, 0); }
  GameModelBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameModelBuilder &operator=(const GameModelBuilder &);
  flatbuffers::Offset<GameModel> Finish() {
    auto o = flatbuffers::Offset<GameModel>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<GameModel> CreateGameModel(flatbuffers::FlatBufferBuilder &_fbb,
   uint32_t username = 150,
   int64_t level = 100,
   flatbuffers::Offset<flatbuffers::Vector<const SkillModel *>> skills = 0,
   int32_t gold = 0) {
  GameModelBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_gold(gold);
  builder_.add_skills(skills);
  builder_.add_username(username);
  return builder_.Finish();
}

inline const GameModel *GetGameModel(const void *buf) { return flatbuffers::GetRoot<GameModel>(buf); }

inline bool VerifyGameModelBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<GameModel>(); }

inline void FinishGameModelBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<GameModel> root) { fbb.Finish(root); }

}  // namespace fbs

#endif  // FLATBUFFERS_GENERATED_MODEL_FBS_H_
